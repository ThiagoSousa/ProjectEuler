# Problema 3
The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?

## Solução
É um problema também bem simples. Precisamos encontrar o maior fator primo desse número grande.

Primeiramente, número primos são aqueles números que só são divisíveis por 1 ou por eles mesmo.

Segundamente, fatores primos é uma lista de números primos, que, ao multiplicarmos resulta no número original. Como no exemplo dado, 5 * 7 * 13 * 29 resulta em 13195. Podemos obter essa lista, e consequentemente o maior fator primo, dividindo o número por números primos em ordem crescente. Por exemplo, 13195/5 = 2639/7= 377/13 = 29/29 = 1. Assim, o maior fator primo é 29.

Assim, para resolver o problema, podemos fazer o mesmo para o número em questão. O pseudo-código seria o seguinte:
```
n = 600851475143
p = 3
enquanto (n!=1) faça
    se (n mod p ==0) n = n/p
    senão p = proximo_primo(p)
fim

```

Começamos pelo número original e o menor primo que é 3. Nem comecei por 2, pois já sei que não é divisível por 2, pois não é par. Assim sendo, enquanto o número for maior que 1, vai se dividindo o número por um primo que o divide. Se o primo não divide, então vai para o próximo primo. Assim sendo, podemos obter todos os fatores primos, para ser sincero, não somente o último. Mas e a função *proximo_primo(n)*? Pois é, para calcular o próximo primo, podemos fazer duas funções:

* **proximo_primo(n)**: simplismente vê se o número é primo, senão vai incrementando até achar o próximo primo da sequência
* **é_primo(n)**: verifica se não há divisores de n, senão 1 ou ele mesmo. Passa cada número até a raiz quadrada de *n* e retorna falso se encontrar algum divisor.  Não preciso verificar até *n*, pois o maior divisor é até raiz de *n* somado de 1, se ignorarmos os números pares. Assim, podemos passar de dois em dois

```
função proximo_primo(n){
    n++
    enquanto (!éprimo(n)) n++
    retorna n
}
```

```
função é_primo(n){
    se n<=1 retorna falso
    se n==2 retorna verdadeiro
    se (n mod 2 == 0) retorna falso
    para i=3 até raiz(n)+1 passando 2 faça
        se (n mod i == 0) retorna falso
    fim
    retorna verdadeiro
}
```

# Problem 3
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

## Solution
It is also a very simple problem. We need to find the largest prime factor of this large number.

First, prime numbers are those numbers that are only divisible by 1 or by themselves.

Secondly, prime factors of a number is a list of prime numbers, which, by multiplying them, results in the original number. As in the given example, 5 * 7 * 13 * 29 results in 13195. We can obtain this list, and consequently the largest prime factor, by dividing the number by prime numbers in ascending order. For example, 13195/5 = 2639/7 = 377/13 = 29/29 = 1. Thus, the largest prime factor is 29.

So, to solve the problem, we can do the same for the number in question. The pseudo-code would be as follows:
(I.e.
```
n = 600851475143
p = 3
while (n!=1)
    if (n mod p ==0) n = n/p
    else p = next_prime(p)
end
```

We start with the original number and the smallest prime that is 3. I didn't start with 2, since I already know that it is not divisible by 2, because it is not even. Thus, while the number is greater than 1, the number is divided by a divisor prime number (prime factor). If the prime does not divide the number, then go to the next one. So we can get all the prime factors, to be honest, not just the last. But, what about the *next_prime(n)* function? Well, to calculate the next prime, we can do two functions:

* **next_prime(n)**: simply check if the number is prime, otherwise increment until you find the next prime of the sequence
* **is_prime(n)**: check if there are no divisors of *n*, otherwise 1 or itself. The function iterates each number up to square root of *n* and returns false if it finds any divisor. I do not need to check up to *n*, since the largest divisor is sqrt of *n*+1 if we ignore even numbers. Thus, we can iterate two by two.

```
function next_prime(n){
    n++
    while (!isprime(n)) n++
    return n
}
```

```
function is_prime(n){
    if n<=1 return false
    if n==2 return true
    if (n mod 2 == 0) return false
    for i=3 to sqrt(n)+1 step 2 do
        if (n mod i == 0) return false
    end
    return true
}
```

I am not going to place the result here but, it will be in the video.

